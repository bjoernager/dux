/*
	Copyright 2021 Gabriel Jensen

	This file is part of u8c.

	u8c is free software: you can redistribute it and/or modify it under the
	terms of the GNU Affero General Public License as published by the Free
	Software Foundation, either version 3 of the License, or (at your
	option) any later version.

	u8c is distributed in the hope that it will be useful, but WITHOUT ANY
	WARRANTY; without even the implied warranty of MERCHANTABILITY or
	FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public
	License for more details.

	You should have received a copy of the GNU Affero General Public License
	along with u8c. If not, see <https://www.gnu.org/licenses/>.
*/

#if !defined(u8c_key_4grZQR1RdsRJL14e)
#define u8c_key_4grZQR1RdsRJL14e

#include <climits>  /* CHAR_BIT */
#include <cstdint>  /* std::int_least16_t, std::int_least32_t, std::int_least64_t, std::int_least8_t, std::intmax_t, std::uint_least16_t, std::uint_least32_t, std::uint_least64_t, std::uint_least8_t, std::uintmax_t */
#include <cstdlib>  /* std::abort */
#include <iostream> /* std::cerr, std::endl */

#define u8c_assert(expr) \
	if constexpr (!u8c::dbg) { \
		/*if consteval { \
			static_assert(expr); \
		} \
		else*/ if (!(expr)) [[unlikely]] { \
			std::cerr << "u8c :: \"" << __FILE__ "\" @ " << __LINE__ << ": Assertion failed: expression \"" << #expr << "\" evaluates to false." << std::endl; \
			std::abort(); \
		} \
	} \

#if defined(__GNUC__) || defined(__clang__)
#define u8c_attr_abitag(...) gnu::abi_tag(__VA_ARGS__)
#define u8c_attr_allocsz(...) gnu::alloc_size(__VA_ARGS__)
#define u8c_attr_artif gnu::artificial
#define u8c_attr_cold gnu::cold
#define u8c_attr_const gnu::const
#define u8c_attr_fmt gnu::format
#define u8c_attr_malloc gnu::malloc
#define u8c_attr_nonnull(...) gnu::nonnull(__VA_ARGS__)
#define u8c_attr_hot gnu::hot
#define u8c_attr_inline gnu::always_inline
#define u8c_attr_pure gnu::pure
#define u8c_attr_retnonnull gnu::returns_nonnull
#define u8c_attr_sect gnu::section
#define u8c_attr_used gnu::used
#else
#define u8c_attr_abitag(...)
#define u8c_attr_allocsz(...)
#define u8c_attr_artif
#define u8c_attr_cold
#define u8c_attr_const
#define u8c_attr_fmt
#define u8c_attr_hot
#define u8c_attr_inline
#define u8c_attr_malloc
#define u8c_attr_nonnull(...)
#define u8c_attr_pure
#define u8c_attr_retnonnull
#define u8c_attr_sect
#define u8c_attr_used
#endif
#if defined(__clang__)
#define u8c_attr_noderef clang::noderef
#define u8c_attr_nodup clang::noduplicate
#define u8c_attr_noesc(...) clang::noescape(__VA_ARGS__)
#else
#define u8c_attr_noderef
#define u8c_attr_nodup
#define u8c_attr_noesc(...)
#endif

#define u8c_bytec(expr) (static_cast<u8c::byte>(INT8_C(expr)))
#define u8c_int16c(expr) (static_cast<u8c::int16>(INT16_C(expr)))
#define u8c_int32c(expr) (static_cast<u8c::int32>(INT32_C(expr)))
#define u8c_int64c(expr) (static_cast<u8c::int64>(INT64_C(expr)))
#define u8c_intmaxc(expr) (static_cast<u8c::intmax>(INTMAX_C(expr)))
#define u8c_ubytec(expr) (static_cast<u8c::ubyte>(UINT8_C(expr)))
#define u8c_uint16c(expr) (static_cast<u8c::uint16>(UINT16_C(expr)))
#define u8c_uint32c(expr) (static_cast<u8c::uint32>(UINT32_C(expr)))
#define u8c_uint64c(expr) (static_cast<u8c::uint64>(UINT64_C(expr)))
#define u8c_uintmaxc(expr) (static_cast<u8c::uintmax>(UINTMAX_C(expr)))

#if defined(__GNUC__) || defined(__clang__)
#define u8c_restr __restrict__
#elif defined(__INTEL_COMPILER) || defined(_MSC_VER)
#define u8c_restr __restrict
#else
#define u8c_restr
#endif

namespace u8c {
	using byte    = signed char;
	using int16   = std::int_least16_t;
	using int32   = std::int_least32_t;
	using int64   = std::int_least64_t;
	using intmax  = std::intmax_t;
	using size    = decltype(0x0uz);
	using ssize   = decltype(0x0z);
	using ubyte   = unsigned char;
	using uint16  = std::uint_least16_t;
	using uint32  = std::uint_least32_t;
	using uint64  = std::uint_least64_t;
	using uintmax = std::uintmax_t;
	template<typename T> concept utf   = std::is_same_v<T,char16_t> || std::is_same_v<T,char32_t> || std::is_same_v<T,char8_t>;
	enum class endi : bool {
		big    = true,
		little = false,
	};
	template<typename T> [[nodiscard,u8c_attr_allocsz(0x3),u8c_attr_malloc,u8c_attr_nonnull(0x1)]] constexpr auto renew(T *            ptr,u8c::size sz,u8c::size newsz) -> T *;
	template<typename T>                                                                           constexpr auto renew(std::nullptr_t,    u8c::size sz,u8c::size newsz) -> T * = delete;
	constexpr auto bytesz = static_cast<u8c::ubyte>(CHAR_BIT);
	constexpr auto dbg    =
#if defined(NDEBUG) || !defined(_DEBUG)
	                        false;
#else
	                        true;
#endif
	constexpr auto unimax = U'\U00010FFF';
	constexpr auto ver    = u8c_uint64c(0x1B);
}

#include <u8c/misc.d/renew>

#endif
