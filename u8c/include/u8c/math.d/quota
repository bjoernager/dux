/*
	Copyright 2021 Gabriel Jensen

	This file is part of u8c.

	u8c is free software: you can redistribute it and/or modify it under the
	terms of the GNU Affero General Public License as published by the Free
	Software Foundation, either version 3 of the License, or (at your
	option) any later version.

	u8c is distributed in the hope that it will be useful, but WITHOUT ANY
	WARRANTY; without even the implied warranty of MERCHANTABILITY or
	FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public
	License for more details.

	You should have received a copy of the GNU Affero General Public License
	along with u8c. If not, see <https://www.gnu.org/licenses/>.
*/

#if !defined(u8c_key_k92caE4RpzrErnKD)
#define u8c_key_k92caE4RpzrErnKD

#include <compare>  /* std::partial_ordering */
#include <concepts> /* std:convertible_to, std::integral, std::signed_integral */

template<std::signed_integral T> constexpr auto u8c::quota<T>::inf() noexcept -> u8c::quota<T> {
	auto tmp = u8c::quota<T>();
	tmp._flags = u8c_ubytec(0b10);
	return tmp;
}
template<std::signed_integral T> constexpr auto u8c::quota<T>::isinf() const noexcept -> bool {
	return (this->_flags & u8c_ubytec(0b10)) == u8c_ubytec(0b10);
}
template<std::signed_integral T> constexpr auto u8c::quota<T>::isnan() const noexcept -> bool {
	return (this->_flags & u8c_ubytec(0b1)) == u8c_ubytec(0b1);
}
template<std::signed_integral T> constexpr auto u8c::quota<T>::lower() const noexcept -> T {
	return this->_lower;
}
template<std::signed_integral T> constexpr auto u8c::quota<T>::nan() noexcept -> u8c::quota<T> {
	auto tmp = u8c::quota<T>();
	tmp._flags = u8c_ubytec(0b1);
	return tmp;
}
template<std::signed_integral T> constexpr auto u8c::quota<T>::upper() const noexcept -> T {
	return this->_upper;
}
template<std::signed_integral T> template<std::convertible_to<T> T0> constexpr auto u8c::quota<T>::operator <=> (u8c::quota<T0> const & _oth) const noexcept -> std::partial_ordering {
	if (this->isinf()) {
		return std::partial_ordering::greater;
	}
	if (_oth.isinf()) {
		return std::partial_ordering::less;
	}
	if (this->isnan() || _oth.isnan()) [[unlikely]] {
		return std::partial_ordering::unordered;
	}
	auto const tmp0 = this->upper() * _oth.lower();
	auto const tmp1 = _oth.upper() * this->lower();
	return tmp0 <=> tmp1;
}
template<std::signed_integral T> template<std::convertible_to<T> T0> constexpr auto u8c::quota<T>::operator == (u8c::quota<T0> const & _oth) const noexcept -> bool {
	if (this->isinf() && _oth.isinf()) [[unlikely]] {
		return true;
	}
	if (this->isnan() || _oth.isnan()) [[unlikely]] {
		return false;
	}
	if (this->_flags != _oth._flags) [[unlikely]] {
		return false;
	}
	return this->upper() * _oth.lower() == _oth.upper() * this->lower();
}
template<std::signed_integral T> template<std::integral T0> constexpr u8c::quota<T>::operator T0 () const noexcept {
	return u8c::trunc<T0>(this->_upper / this->_lower);
}
template<std::signed_integral T> template<std::convertible_to<T> T0> constexpr u8c::quota<T>::quota(T0 const _val) noexcept {
	if (u8c::isnan(_val)) [[unlikely]] {
		this->_flags |= u8c_ubytec(0b1);
	}
	else if (u8c::isinf(_val)) [[unlikely]] {
		this->_flags |= u8c_ubytec(0b10);
	}
	else {
		this->_upper = T{_val};
		this->_lower = T{0x1};
	}
}
template<std::signed_integral T> template<std::signed_integral T0> constexpr u8c::quota<T>::quota(T0 const _upper,T0 const _lower) noexcept {
	this->_upper = _upper;
	this->_lower = _lower;
}

#endif