/*
	Copyright 2021 Gabriel Jensen

	This file is part of u8c.

	u8c is free software: you can redistribute it and/or modify it under the
	terms of the GNU Affero General Public License as published by the Free
	Software Foundation, either version 3 of the License, or (at your
	option) any later version.

	u8c is distributed in the hope that it will be useful, but WITHOUT ANY
	WARRANTY; without even the implied warranty of MERCHANTABILITY or
	FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public
	License for more details.

	You should have received a copy of the GNU Affero General Public License
	along with u8c. If not, see <https://www.gnu.org/licenses/>.
*/

#if !defined(u8c_key_nVkgRbXZfcq3BG8J)
#define u8c_key_nVkgRbXZfcq3BG8J

#include <algorithm>   /* std::copy */
#include <cstddef>     /* u8c::size */
#include <stdexcept>   /* std::invalid_argument, std::out_of_range */
#include <type_traits> /* std::is_same_v */
#include <vector>      /* std::vector */

template<u8c::utf T,u8c::utf T0> constexpr auto u8c::cnv(T0 const * const u8c_restr _begin,T0 const * const u8c_restr _end) -> u8c::arr<T> {
	if (_begin == nullptr || _end == nullptr) [[unlikely]] {
		throw std::invalid_argument("Null pointer provided as parameter.");
	}
	u8c::arr<T0> in(_begin,_end);
	u8c::arr<T> out;
	if constexpr (std::is_same_v<T0,T>) {
		out.alloc(static_cast<u8c::size>(_end - _begin));
		std::copy(_begin,_end,out.begin());
		return out;
	}
	else {
		if constexpr (std::is_same_v<T0,char16_t>) {
		}
		else if constexpr (std::is_same_v<T0,char32_t>) {
			for (auto const tmp : in) {
				if constexpr (std::is_same_v<T,char16_t>) {
					if (tmp >= u8c_uint32c(0x10000)) { /* Two hextets. */
						char16_t const tmp0 = tmp - u8c_uint16c(0x10000);
						out.app((tmp0 / u8c_uint16c(0x400) + u8c_uint16c(0xD800)));
						out.app((tmp0 % u8c_uint16c(0x400) + u8c_uint16c(0xDC00)));
					}
					else {
						/* One hextet. */
						out.app((static_cast<char16_t>(tmp)));
					}
				}
				else {
					if (tmp >= u8c_uint32c(0x10000)) { /* Four octets. */
						out.app((u8c_ubytec(0b11110000) + static_cast<char8_t>(tmp >> u8c_uint32c(0x12) & u8c_uint32c(0b00000111))));
						out.app((u8c_ubytec(0b10000000) + static_cast<char8_t>(tmp >> u8c_uint32c(0xC) & u8c_uint32c(0b00111111))));
						out.app((u8c_ubytec(0b10000000) + static_cast<char8_t>(tmp >> u8c_uint32c(0x6) & u8c_uint32c(0b00111111))));
						out.app((u8c_ubytec(0b10000000) + static_cast<char8_t>(tmp & u8c_uint32c(0b00111111))));
					}
					else if (tmp >= U'\u0800') { /* Three octets. */
						out.app((u8c_ubytec(0xE0) + static_cast<char8_t>(tmp >> u8c_uint32c(0xC) & u8c_uint32c(0b00001111))));
						out.app((u8c_ubytec(0x80) + static_cast<char8_t>(tmp >> u8c_uint32c(0x6) & u8c_uint32c(0b00111111))));
						out.app((u8c_ubytec(0x80) + static_cast<char8_t>(tmp & u8c_uint32c(0b00111111))));
					}
					else if (tmp >= U'\u0080') { /* Two octets. */
						out.app((u8c_ubytec(0xC0) + static_cast<char8_t>(tmp >> u8c_uint32c(0x6) & u8c_uint32c(0b00111111))));
						out.app((u8c_ubytec(0x80) + static_cast<char8_t>(tmp & u8c_uint32c(0b00111111))));
					}
					else {
						/* One octet. */
						out.app(static_cast<char8_t>(tmp));
					}
				}
			}
			return out;
		}
		else {
			if constexpr (std::is_same_v<T,char16_t>) {
			}
			else {
				for (u8c::size n = 0x0uz;n < in.sz();n += 0x1uz) {
					auto const tmp = in[n];
					auto chr = U'\u0000';
					if (tmp >= u8c_ubytec(0b11110000)) { /* Four octets. */
						chr =  (tmp ^ u8c_uint32c(0b11110000)) << u8c_uint32c(0x12);
						chr += (in[n + 0x1uz] ^ u8c_uint32c(0b10000000)) << u8c_uint32c(0xC);
						chr += (in[n + 0x2uz] ^ u8c_uint32c(0b10000000)) << u8c_uint32c(0x6);
						chr += in[n + 0x3uz] ^ u8c_uint32c(0b10000000);
						n   += 0x3uz;
					}
					else if (tmp >= u8c_ubytec(0b11100000)) { /* Three octets. */
						chr =  (tmp ^ u8c_uint32c(0b11100000)) << u8c_uint32c(0xC);
						chr += (in[n + 0x1uz] ^ u8c_uint32c(0b10000000)) << u8c_uint32c(0x6);
						chr += in[n + 0x2uz] ^ u8c_uint32c(0b10000000);
						n   += 0x2uz;
					}
					else if (tmp >= u8c_ubytec(0b11000000)) { /* Two octets. */
						chr =  (tmp ^ u8c_uint32c(0b11000000)) << u8c_uint32c(0x6);
						chr += in[n + 0x1uz] ^ u8c_uint32c(0b10000000);
						n   += 0x1uz;
					}
					else {
						/* One octet. */
						chr = tmp;
					}
					out.app(chr);
				}
			}
		}
	}
}

#endif
