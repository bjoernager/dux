/*
	Copyright 2021 Gabriel Jensen

	This file is part of u8c.

	u8c is free software: you can redistribute it and/or modify it under the
	terms of the GNU Affero General Public License as published by the Free
	Software Foundation, either version 3 of the License, or (at your
	option) any later version.

	u8c is distributed in the hope that it will be useful, but WITHOUT ANY
	WARRANTY; without even the implied warranty of MERCHANTABILITY or
	FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public
	License for more details.

	You should have received a copy of the GNU Affero General Public License
	along with u8c. If not, see <https://www.gnu.org/licenses/>.
*/

#if !defined(u8c_key_zQ92KNf0pxkz48g2)
#define u8c_key_zQ92KNf0pxkz48g2

#include <algorithm>   /* std::copy, std::fill */
#include <cstdlib>     /* std::abort */
#include <iostream>    /* std::cerr, std::endl */
#include <stdexcept>   /* std::invalid_argument, std::out_of_range */
#include <type_traits> /* std::is_constant_evaluated */

template<typename T> constexpr auto u8c::arr<T>::alloc(u8c::size const _num) -> void {
	if (this->isstatic()) [[unlikely]] {
		this->_isstatic = false;
	}
	else {
		::delete[] this->_ptr;
	}
	this->_ptr = ::new T[_num];
	this->_sz  = _num;
}
template<typename T> constexpr auto u8c::arr<T>::app(u8c::arr<T> const & _oth) -> u8c::arr<T> const & {
	this->realloc(this->sz() + _oth.sz());
	std::copy(_oth.begin(),_oth.end(),this->begin() + this->sz() - _oth.sz());
	return *this;
}
template<typename T> constexpr u8c::arr<T>::arr(T const * const _begin,T const * const _end) {
	this->set(_begin,_end);
}
template<typename T> constexpr u8c::arr<T>::arr(u8c::size const _num) {
	this->alloc(_num);
}
template<typename T> constexpr u8c::arr<T>::arr(u8c::arr<T> const & _oth) {
	this->set(_oth);
}
template<typename T> template<u8c::size N> constexpr u8c::arr<T>::arr(T const (&_arr)[N]) noexcept {
	this->set(_arr);
}
template<typename T> template<typename T0> requires std::convertible_to<T0,T> constexpr u8c::arr<T>::arr(T0 const _val) {
	this->set(_val);
}
template<typename T> template<typename T0> requires std::convertible_to<T0,T> constexpr u8c::arr<T>::arr(u8c::size const _num,T0 const _val) {
	this->alloc(_num);
	this->fill(this->begin(),this->end(),_val);
}
template<typename T> constexpr auto u8c::arr<T>::begin() const noexcept -> T * {
	return this->_ptr;
}
template<typename T> constexpr auto u8c::arr<T>::end() const noexcept -> T * {
	return this->begin() + this->_sz;
}
template<typename T> template<typename T0> requires std::convertible_to<T0,T> constexpr auto u8c::arr<T>::fill(T0 const _val) -> void {
	this->fill(this->begin(),this->end(),_val);
}
template<typename T> template<typename T0> requires std::convertible_to<T0,T> constexpr auto u8c::arr<T>::fill(T * const u8c_restr _begin,T * const u8c_restr _end,T0 const _val) -> void {
	if (this->sz() == 0x0uz) [[unlikely]] {
		return; /* slime incident */
	}
	if (_begin < this->begin() || _end > this->end()) [[unlikely]] {
		throw std::out_of_range("Beginning or end are out of this array's range.");
	}
	if (this->isstatic()) [[unlikely]] {
		this->alloc(static_cast<u8c::size>(_end - _begin + 0x1uz));
	}
	std::fill(this->begin(),this->end(),static_cast<T>(_val));
}
template<typename T> constexpr auto u8c::arr<T>::isstatic() const noexcept -> bool {
	return this->_isstatic;
}
template<typename T> constexpr auto u8c::arr<T>::operator = (u8c::arr<T> const & _oth) -> u8c::arr<T> const & {
	this->set(_oth);
	return *this;
}
template<typename T> constexpr auto u8c::arr<T>::operator [] (u8c::size const _pos) const noexcept -> T & {
	if constexpr (u8c::dbg) {
		if (_pos > this->sz()) [[unlikely]] {
			//std::cerr << "u8c :: " << std::source_location::current().function_name() << " :: Input parameter is out of range." << std::endl;
			std::cerr << "u8c :: " << __func__ << " :: Input parameter is out of range." << std::endl;
			std::abort();
		}
	}
	return this->begin()[_pos];
}
template<typename T> constexpr auto u8c::arr<T>::realloc(u8c::size const _num) -> void {
	if (this->sz() == 0x0uz) [[unlikely]] {
		return this->alloc(_num);
	}
	if (this->isstatic()) [[unlikely]] {
		this->_isstatic = false;
	}
	this->_ptr = u8c::renew(this->begin(),this->sz(),_num);
	this->_sz  = _num;
}
template<typename T> constexpr auto u8c::arr<T>::set(T const * const u8c_restr _begin,T const * const u8c_restr _end) -> void {
	if constexpr (u8c::dbg) {
		if (_begin == nullptr || _end == nullptr) [[unlikely]] {
			throw std::invalid_argument("Provided parameter has value of nullptr.");
		}
	}
	this->alloc(static_cast<u8c::size>(_end - _begin + 0x1uz));
	std::copy(_begin,_end,this->begin());
}
template<typename T> constexpr auto u8c::arr<T>::set(u8c::arr<T> const & _oth) -> void {
	this->set(_oth.begin(),_oth.end());
}
template<typename T> template<u8c::size N> constexpr auto u8c::arr<T>::set(T const (&_arr)[N]) noexcept -> void {
	this->~arr();
	this->_isstatic = true;
	this->_ptr      = _arr;
	this->_sz       = N;
}
template<typename T> template<typename T0> requires std::convertible_to<T0,T> constexpr auto u8c::arr<T>::set(T0 const _val) -> void {
	this->alloc(0x1uz);
	*this->begin() = _val;
}
template<typename T> constexpr auto u8c::arr<T>::sub(T const * const u8c_restr _begin,T const * const u8c_restr _end) const -> u8c::arr<T> {
	if (_begin < this->begin() || _end > this->end()) [[unlikely]] {
		throw std::out_of_range("Beginning or end are out of this array's range.");
	}
	u8c::size const sz = static_cast<u8c::size>(_end - _begin) + 0x1uz;
	u8c::arr<T> arr;
	if (this->isstatic()) [[unlikely]] {
		arr._sz  = sz;
		arr._ptr = _begin;
	}
	else {
		arr.alloc(sz);
		std::copy(_begin,_end,arr.begin());
	}
	return arr;
}
template<typename T> constexpr auto u8c::arr<T>::sz() const noexcept -> u8c::size {
	return this->_sz;
}
template<typename T> constexpr u8c::arr<T>::~arr<T>() noexcept {
	if (this->isstatic()) {
		return;
	}
	::delete[] this->_ptr;
}

#endif
